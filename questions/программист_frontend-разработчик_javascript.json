{
    "category_full_form": "Программист_Frontend разработчик_Javascript",
    "category_human_form": "Frontend разработчик_Javascript",
    "category_filename_form": "программист_frontend-разработчик_javascript",
    "questions": [
        {
            "question": "Что такое генераторные функции?",
            "right_answer": "Введенные в версии ES6, генераторные функции являются особого класса функций."
        },
        {
            "question": "Объясните ключевое слово «this».",
            "right_answer": "Ключевое слово «this» относится к объекту, свойством которого является функция."
        },
        {
            "question": "Что такое Immediately Invoked Function в JavaScript?",
            "right_answer": "Immediately Invoked Function (IIFE) - это функция, которая запускается сразу после определения."
        },
        {
            "question": "Что нужно сделать, чтобы внедрить Лексическую область видимости на практике?",
            "right_answer": "Для поддержки лексической области видимости внутреннее состояние объекта функции JavaScript должно включать не только код функции, но и ссылку на текущую цепочку области видимости."
        },
        {
            "question": "Объясните Scope и Scope Chain в javascript.",
            "right_answer": "Scope в JS определяет доступность переменных и функций в различных частях кода."
        },
        {
            "question": "Что вы понимаете под шаблонами проектирования JavaScript?",
            "right_answer": "Шаблоны проектирования JavaScript - это повторяемые подходы к ошибкам, которые иногда возникают при создании браузерных приложений на JavaScript. Они действительно помогают нам сделать наш код более стабильным. Они в основном делятся на 3 категории: Шаблон создания объектов, Структурный шаблон проектирования, Поведенческий шаблон проектирования."
        },
        {
            "question": "Какие примитивные типы данных существуют в JavaScript?",
            "right_answer": "Примитив - это тип данных, который не состоит из других типов данных. Он способен отображать только одно значение за раз. По определению, каждый примитив является встроенным типом данных (компилятор должен знать о них), однако не все встроенные наборы данных являются примитивами. В JavaScript существует 5 различных форм базовых данных. Доступны следующие значения: Boolean, Undefined, Null, Number, String"
        },
        {
            "question": "Почему мы используем слово «отладчик» в javascript?",
            "right_answer": "Отладчик для браузера должен быть активирован для отладки кода. Встроенные отладчики могут быть включены и выключены, требуя от пользователя сообщения о неисправностях. Оставшаяся часть кода должна остановить выполнение перед переходом к следующей строке во время отладки."
        },
        {
            "question": "Какой метод используется для извлечения символа из определенного индекса?",
            "right_answer": "Функция charAt() строки JavaScript находит элемент char по указанному индексу. Номер индекса начинается с 0 и продолжается до n-1, где n - длина строки. Значение индекса должно быть положительным, больше или равным длине строки."
        },
        {
            "question": "Объясните передачу по значению и передачу по ссылке.",
            "right_answer": "В JavaScript примитивные типы данных передаются по значению, а не примитивные типы данных передаются по ссылке."
        },
        {
            "question": "Для чего используется конструкторная функция в javascript?",
            "right_answer": "Конструкторные функции используются для создания объектов в javascript."
        },
        {
            "question": "Объясните методы call(), apply() и bind().",
            "right_answer": "1. call():\n\nЭто предопределенный метод в javascript.\nЭтот метод вызывает метод (функцию), указывая объект-владельца.\nПример 1:\nfunction sayHello(){\n  return \"Hello \" + this.name;\n}\n\nvar obj = {name: \"Sandy\"};\n\nsayHello.call(obj);\n\n// Возвращает \"Hello Sandy\"\nМетод call() позволяет объекту использовать метод (функцию) другого объекта.\nПример 2:\nvar person = {\n  age: 23,\n  getAge: function(){\n    return this.age;\n  }\n}\nvar person2 = {age:  54};\nperson.getAge.call(person2);\n// Возвращает 54\nМетод call() принимает аргументы:\nfunction saySomething(message){\n  return this.name + \" is \" + message;\n}\nvar person4 = {name:  \"John\"};\nsaySomething.call(person4, \"awesome\");\n// Возвращает \"John is awesome\"\n\napply()\n\nМетод apply аналогичен методу call(). Единственное отличие в том, что,\n\nметод call() принимает аргументы отдельно, в то время как метод apply() принимает аргументы в виде массива.\n\nfunction saySomething(message){\n  return this.name + \" is \" + message;\n}\nvar person4 = {name:  \"John\"};\nsaySomething.apply(person4, [\"awesome\"]);\n\n2. bind():\n\nЭтот метод возвращает новую функцию, где значение ключевого слова “this” будет привязано к объекту-владельцу, который предоставляется в качестве параметра.\nПример с аргументами:\nvar bikeDetails = {\n    displayDetails: function(registrationNumber,brandName){\n    return this.name+ \" , \"+ \"bike details: \"+ registrationNumber + \" , \" + brandName;\n  }\n}\n\nvar person1 = {name:  \"Vivek\"};\n\nvar detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, \"TS0122\", \"Bullet\");\n\n// Привязывает функцию displayDetails к объекту person1\n\n\ndetailsOfPerson1();\n// Возвращает Vivek, bike details: TS0122, Bullet"
        },
        {
            "question": "Укажите некоторые преимущества JavaScript.",
            "right_answer": "У JavaScript есть много преимуществ. Некоторые из них: JavaScript выполняется как на стороне клиента, так и на стороне сервера. Существует множество фронтенд-фреймворков, которые вы можете изучить и использовать. Однако, если вы хотите использовать JavaScript на бэкенде, вам нужно будет изучить NodeJS. В настоящее время это единственный фреймворк JavaScript, который можно использовать на бэкенде. JavaScript - простой язык для изучения. Веб-страницы теперь имеют больше функциональности благодаря JavaScript. Для конечного пользователя JavaScript работает довольно быстро."
        },
        {
            "question": "В чем разница между прототипным и классическим наследованием?",
            "right_answer": "Программисты создают объекты, которые являются представлениями сущностей реального времени, в традиционном ОО программировании. Классы и объекты - два вида абстракций. Класс является обобщением объекта, в то время как объект является абстракцией реального объекта. Например, Транспортное средство - это специализация Автомобиля. В результате, автомобили (класс) происходят от транспортных средств (объект).\n\nКлассическое наследование отличается от прототипного наследования тем, что классическое наследование ограничено классами, которые наследуются от оставшихся классов, в то время как прототипное наследование позволяет любому объекту быть клонированным с помощью метода связывания объектов. Несмотря на слишком многочисленные детали, прототип в основном служит шаблоном для других объектов, независимо от того, расширяют ли они родительский объект или нет."
        },
        {
            "question": "Каково различие между ключевыми словами var и let в JavaScript?",
            "right_answer": "Некоторые различия: С самого начала ключевое слово 'var' использовалось в программировании на JavaScript, в то время как ключевое слово 'let' было добавлено только в 2015 году. Ключевое слово 'var' имеет область видимости функции. В любом месте функции переменная, указанная с помощью var, доступна, но в случае с 'let' область видимости переменной, объявленной с ключевым словом 'let', ограничена блоком, в котором она объявлена. Давайте начнем с области видимости блока. В ECMAScript 2015 let и const поднимаются, но не инициализируются. Ссылка на переменную в блоке до объявления переменной приводит к ошибке ReferenceError, потому что переменная находится в 'временной зоне мертвых' с начала блока до обработки объявления."
        }
    ]
}