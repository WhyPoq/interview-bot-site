{
    "category_full_form": "Программист_Full Stack разработчик_Алгоритмы и структуры данных",
    "category_human_form": "Full Stack разработчик_Алгоритмы и структуры данных",
    "category_filename_form": "программист_full-stack-разработчик_алгоритмы-и-структуры-данных",
    "questions": [
        {
            "question": "Какие основные операции выполняются с структурой данных Deque?",
            "right_answer": "Вот основные операции, доступные в деке: insertFront(), insertLast(), deleteFront(), deleteLast(), getFront(), getRear(), isEmpty(), isFull()."
        },
        {
            "question": "Перечислите типы деревьев?",
            "right_answer": "Вопросы с собеседования по структурам данных, подобные этому, очень распространены и часто задаются"
        },
        {
            "question": "Что такое Dequeue?",
            "right_answer": "Это двусторонняя очередь, или структура данных, в которой элементы могут быть вставлены или удалены с обоих концов (FRONT и REAR)."
        },
        {
            "question": "Разница между массивом и связным списком.",
            "right_answer": "Массивы\tСвязные списки\nМассив - это коллекция элементов данных одного типа.\tСвязный список - это коллекция сущностей, известных как узлы. Узел делится на две секции: данные и адрес.\nОн хранит элементы данных в одной памяти.\tОн хранит элементы в случайном порядке или в любом месте в памяти.\nРазмер памяти массива фиксирован и не может быть изменен во время выполнения программы.\tРазмер памяти связного списка выделяется во время выполнения программы.\nЭлементы массива не зависят друг от друга.\tЭлементы связного списка зависят друг от друга.\nДоступ к элементу в массиве проще и быстрее.\tВ связном списке требуется время для доступа к элементу.\nИспользование памяти неэффективно в случае массива.\tИспользование памяти эффективно в случае связных списков.\nОперации, такие как вставка и удаление, занимают больше времени в массиве.\tОперации, такие как вставка и удаление, выполняются быстрее в связном списке."
        },
        {
            "question": "Определите Красно-черное дерево и его применения",
            "right_answer": "Красно-черные деревья - это тип самобалансирующегося двоичного дерева поиска. Рудольф Байер изобрел его в 1972 году и назвал его 'симметричными двоичными B-деревьями'. Красно-черное дерево - это двоичное дерево, в котором каждый узел имеет атрибут цвета, либо красный, либо черный. Путем сравнения цветов узлов на любом простом пути от корня к листу красно-черные деревья гарантируют, что ни один путь не будет более чем вдвое длиннее любого другого, обеспечивая тем самым общий баланс дерева. Красно-черные деревья похожи на двоичные деревья в том, что они оба хранят свои данные в двоичных форматах дополнительного кода. Однако у красно-черных деревьев есть одно важное преимущество перед двоичными деревьями: они быстрее доступны. Поскольку красно-черные деревья так быстро доступны, их часто используют для хранения больших объемов данных. Красно-черные деревья могут использоваться для хранения любого типа данных, которые могут быть представлены в виде набора значений. Каждое красно-черное дерево подчиняется следующим правилам: Каждый узел либо красный, либо черный. Корень дерева всегда черный. Нет двух смежных красных узлов. На каждом пути от узла к любому из его потомков NULL одинаковое количество черных узлов. Все листовые узлы черные. Вот некоторые приложения в реальном времени для структуры данных Красно-черное дерево: Большинство функций библиотек самобалансирующихся BST на C++ или Java используют Красно-черные деревья. Используется для реализации планирования процессора Linux. Также используется для снижения временной сложности в алгоритме кластеризации K-средних в машинном обучении. MySQL также использует Красно-черное дерево для индексов таблиц, чтобы сократить время поиска и вставки."
        },
        {
            "question": "Как реализовать очередь, используя стек?",
            "right_answer": "Очередь можно реализовать, используя два стека. Пусть q будет очередью, а stack1 и stack2 - двумя стеками для реализации q. Мы знаем, что стек поддерживает операции push, pop и peek, и используя эти операции, нам нужно эмулировать операции очереди - enqueue и dequeue."
        },
        {
            "question": "Какие примеры алгоритмов разделяй и властвуй?",
            "right_answer": "Quicksort - это название алгоритма сортировки. Метод выбирает опорный элемент и переставляет элементы массива так, чтобы все элементы, меньшие выбранного опорного элемента, переходили на левую сторону опоры, а все элементы, большие опорного элемента, перемещались на правую сторону. Сортировка слиянием также является алгоритмом сортировки. Алгоритм делит массив на две половины, сортирует их рекурсивно, а затем объединяет две отсортированные половины. Целью является определение ближайшей пары точек в коллекции точек на плоскости x-y. Проблему можно решить за время O(n2), вычисляя расстояния между каждой парой точек и сравнивая их, чтобы определить самое короткое расстояние."
        },
        {
            "question": "Что такое обход дерева?",
            "right_answer": "Обход дерева - это процесс посещения всех узлов дерева."
        },
        {
            "question": "Где используются стеки?",
            "right_answer": "Выражение, оценка или преобразование вычисления префиксных, постфиксных и инфиксных выражений\nСинтаксический анализ\nРеверс строки\nПроверка скобок\nОткат"
        },
        {
            "question": "Перечислите некоторые применения многосвязных структур?",
            "right_answer": "Разреженная матрица\nГенерация индексов"
        },
        {
            "question": "Как реализовать стек, используя очереди?",
            "right_answer": "Стек можно реализовать с использованием двух очередей. Мы знаем, что очередь поддерживает операции добавления в конец и удаления из начала. Используя эти операции, нам нужно разработать операции добавления и удаления элементов."
        },
        {
            "question": "Какова временная сложность базовых операций get() и put() в классе HashMap?",
            "right_answer": "Временная сложность составляет O(1), предполагая, что хеш-функция, используемая в хеш-карте, равномерно распределяет элементы по корзинам"
        },
        {
            "question": "Какая структура данных позволяет легко манипулировать элементами в связанном списке?",
            "right_answer": "Ваш ответ покажет собеседнику, что вы понимаете несколько форм структур данных. Он также продемонстрирует вашу способность к решению проблем, установлению приоритетов и быстрым принятием решений. Пример: «Лучшая структура данных для перемещения элементов связанного списка - это структура связанного списка. Вы просто изменяете список, а не создаете массив»."
        },
        {
            "question": "Каковы применения графовой структуры данных?",
            "right_answer": "Транспортные сети, где станции представлены как вершины, а маршруты как рёбра графа\nГрафы утилиты электроэнергии или воды, где вершины - точки подключения, а рёбра - провода или трубы, их соединяющие\nГрафы социальных сетей для определения потока информации и точек роста (рёбра и вершины)\nНейронные сети, где вершины представляют нейроны, а рёбра - синапсы между ними"
        },
        {
            "question": "Что такое зубчатый массив?",
            "right_answer": "Это массив, элементы которого сами являются массивами и могут иметь разные размеры и размеры."
        }
    ]
}