{
	"category_full_form": "Программист_Frontend разработчик_React",
	"category_human_form": "Frontend разработчик_React",
	"category_filename_form": "программист_frontend-разработчик_react",
	"questions": [
		{
			"question": "Как отслеживать изменения в поле объекта в функциональном компоненте?",
			"right_answer": "Для этого вам нужно использовать хук useEffect и передать поле объекта в качестве массива зависимостей.\nuseEffect(() => {\n console.log('Changed!')\n}, [obj.someField])"
		},
		{
			"question": "Что такое пользовательский хук?",
			"right_answer": "Пользовательский хук - это функция, которая позволяет вам повторно использовать логику между различными компонентами. Это способ инкапсулировать повторно используемую логику, чтобы ее можно было легко обмениваться и использовать снова в нескольких компонентах. Пользовательские хуки - это функции, которые обычно начинаются со слова *use* и могут вызывать другие хуки при необходимости."
		},
		{
			"question": "Что такое React Reconciliation?",
			"right_answer": "Согласование - это алгоритм React, используемый для различения одного дерева элементов от другого, чтобы определить части, которые нужно будет заменить."
		},
		{
			"question": "Для чего используется useCallback и как она работает?",
			"right_answer": "Хук useCallback вернет мемоизированную версию обратного вызова, которая изменится только в случае изменения значений одной из зависимостей. Это полезно при передаче обратных вызовов в оптимизированные дочерние компоненты, которые полагаются на равенство ссылок для предотвращения ненужных перерисовок. const callbackValue = useCallback(() => computeFunc(paramA, paramB), [paramA, paramB]);"
		},
		{
			"question": "Какие React хуки вы знаете?",
			"right_answer": "useState: Используется для управления состоянием в функциональных компонентах. useEffect: Используется для выполнения побочных эффектов в функциональных компонентах, таких как получение данных или подписка на события. useContext: Используется для доступа к значению контекста React внутри функционального компонента. useRef: Используется для создания изменяемых ссылок на элементы или значения, которые сохраняются между рендерами. useCallback: Используется для мемоизации функций для предотвращения ненужных повторных рендеров. useMemo: Используется для мемоизации значений для улучшения производительности путем кэширования дорогостоящих вычислений. useReducer: Используется для управления состоянием с помощью функции редуктора, аналогично тому, как работает Redux. useLayoutEffect: Похож на useEffect, но эффект выполняется синхронно после всех мутаций DOM. Эти хуки предоставляют мощные инструменты для управления состоянием, обработки побочных эффектов и повторного использования логики в функциональных компонентах React."
		},
		{
			"question": "В чем разница между Redux и Mobx?",
			"right_answer": "Redux - это более простая и более определенная библиотека управления состоянием, которая следует строгому однонаправленному потоку данных и способствует неизменяемости. Он требует больше шаблонного кода и явных обновлений, но отлично интегрируется с React. Mobx, с другой стороны, предоставляет более гибкий и интуитивно понятный API с меньшим количеством шаблонного кода. Он позволяет вам напрямую изменять состояние и автоматически отслеживает изменения для лучшей производительности. Выбор между Redux и Mobx зависит от ваших конкретных потребностей и предпочтений."
		},
		{
			"question": "Как отследить размонтирование функционального компонента?",
			"right_answer": "Часто useEffect создает ресурсы, которые необходимо очистить или сбросить перед тем, как компонент покинет экран, такие как подписка или идентификатор таймера. Для этого функция, переданная в useEffect, может возвращать функцию очистки. Функция очистки запускается перед тем, как компонент будет удален из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как это обычно бывает), предыдущий эффект очищается перед выполнением следующего эффекта."
		},
		{
			"question": "Что такое props drilling?",
			"right_answer": "Props drilling относится к процессу передачи пропсов через несколько уровней вложенных компонентов, даже если некоторые промежуточные компоненты не используют эти пропсы напрямую. Это может привести к сложной и громоздкой структуре кода."
		},
		{
			"question": "Какие особенности использования useState?",
			"right_answer": "useState возвращает значение состояния и функцию для его обновления. Во время первоначального рендеринга возвращенное состояние соответствует значению, переданному в качестве первого аргумента. Функция setState используется для обновления состояния. Она принимает новое значение состояния в качестве параметра и добавляет повторный рендеринг компонента. Функция setState также может принимать функцию обратного вызова в качестве параметра, которая принимает предыдущее значение состояния в качестве параметра."
		},
		{
			"question": "Как отобразить массив элементов?",
			"right_answer": "Для отображения массива элементов вы можете использовать метод map() для итерации по массиву и возврата нового массива элементов React."
		},
		{
			"question": "Для чего используется useMemo и как он работает?",
			"right_answer": "useMemo используется для кэширования и запоминания результатов вычислений. Передайте функцию создания и массив зависимостей. useMemo будет пересчитывать запомненное значение только тогда, когда значение хотя бы одной из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере."
		},
		{
			"question": "Какие методы жизненного цикла компонента?",
			"right_answer": "Методы жизненного цикла - это способ подключения к различным этапам жизненного цикла компонента, позволяющий выполнять определенный код в определенные моменты."
		}
	]
}
