{
    "category_full_form": "Программист_Full Stack разработчик_Frontend часть_JavaScript",
    "category_human_form": "Full Stack разработчик_JavaScript",
    "category_filename_form": "программист_full-stack-разработчик_frontend-часть_javascript",
    "questions": [
        {
            "question": "Объясните WeakMap в javascript.",
            "right_answer": "В javascript Map используется для хранения пар ключ-значение. Пары ключ-значение могут быть как примитивных, так и не примитивных типов. WeakMap похож на Map с ключевыми различиями: ключи и значения в WeakMap должны всегда быть объектом. Если нет ссылок на объект, то объект будет собран сборщиком мусора."
        },
        {
            "question": "Объясните Scope и Scope Chain в javascript.",
            "right_answer": "Scope в JS определяет доступность переменных и функций в различных частях кода."
        },
        {
            "question": "Объясните Замыкания в JavaScript.",
            "right_answer": "Замыкания - это способность функции запоминать переменные и функции, объявленные в её внешней области видимости."
        },
        {
            "question": "Что вы подразумеваете под шаблонами проектирования JavaScript?",
            "right_answer": "Шаблоны проектирования JavaScript - это повторяемые подходы к ошибкам, которые иногда возникают при создании браузерных приложений на JavaScript. Они действительно помогают нам сделать наш код более стабильным. Они в основном делятся на 3 категории: Шаблон создания объектов, Структурный шаблон проектирования, Поведенческий шаблон проектирования."
        },
        {
            "question": "Объясните методы call(), apply() и bind().",
            "right_answer": "1. call():\n\nЭто предопределенный метод в javascript.\nЭтот метод вызывает метод (функцию), указывая объект-владельца.\nПример 1:\nfunction sayHello(){\n  return \"Hello \" + this.name;\n}\n\nvar obj = {name: \"Sandy\"};\n\nsayHello.call(obj);\n\n// Возвращает \"Hello Sandy\"\nМетод call() позволяет объекту использовать метод (функцию) другого объекта.\nПример 2:\nvar person = {\n  age: 23,\n  getAge: function(){\n    return this.age;\n  }\n}\nvar person2 = {age:  54};\nperson.getAge.call(person2);\n// Возвращает 54\nМетод call() принимает аргументы отдельно:\nfunction saySomething(message){\n  return this.name + \" is \" + message;\n}\nvar person4 = {name:  \"John\"};\nsaySomething.call(person4, \"awesome\");\n// Возвращает \"John is awesome\"\n\napply()\n\nМетод apply аналогичен методу call(). Единственное отличие в том, что,\n\nметод call() принимает аргументы отдельно, в то время как метод apply() принимает аргументы в виде массива.\n\nfunction saySomething(message){\n  return this.name + \" is \" + message;\n}\nvar person4 = {name:  \"John\"};\nsaySomething.apply(person4, [\"awesome\"]);\n\n2. bind():\n\nЭтот метод возвращает новую функцию, где значение ключевого слова “this” будет привязано к объекту-владельцу, который предоставляется в качестве параметра.\nПример с аргументами:\nvar bikeDetails = {\n    displayDetails: function(registrationNumber,brandName){\n    return this.name+ \" , \"+ \"детали велосипеда: \"+ registrationNumber + \" , \" + brandName;\n  }\n}\n\nvar person1 = {name:  \"Vivek\"};\n\nvar detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, \"TS0122\", \"Bullet\");\n\n// Привязывает функцию displayDetails к объекту person1\n\n\ndetailsOfPerson1();\n// Возвращает Vivek, детали велосипеда: TS0122, Bullet"
        },
        {
            "question": "Что такое прототипы объектов?",
            "right_answer": "Все объекты JavaScript наследуют свойства от прототипа. Прототип - это чертеж объекта, который позволяет нам использовать свойства и методы объекта, даже если они не существуют в текущем объекте."
        },
        {
            "question": "Что такое Temporal Dead Zone?",
            "right_answer": "Temporal Dead Zone - это поведение, которое происходит с переменными, объявленными с использованием ключевых слов let и const. Это поведение, когда мы пытаемся получить доступ к переменной до ее инициализации."
        },
        {
            "question": "Является ли JavaScript статически типизированным или динамически типизированным языком?",
            "right_answer": "JavaScript является динамически типизированным языком. В динамически типизированном языке тип переменной проверяется во время выполнения, в отличие от статически типизированного языка, где тип переменной проверяется во время компиляции. Поскольку JavaScript является слабо (динамически) типизированным языком, переменные в JS не связаны с каким-либо типом. Переменная может содержать значение любого типа данных."
        },
        {
            "question": "Какие типы ошибок существуют в JavaScript?",
            "right_answer": "Существует два типа ошибок в JavaScript.\nСинтаксическая ошибка: Синтаксические ошибки - это ошибки или проблемы с орфографией в коде, которые приводят к тому, что программа не выполняется вообще или останавливается на полпути. Обычно также предоставляются сообщения об ошибках.\nЛогическая ошибка: Ошибки рассуждения возникают, когда синтаксис правильный, но логика или программа неверны. В этом случае приложение выполняется без проблем. Однако результаты вывода недостоверны. Иногда их сложнее исправить, чем синтаксические проблемы, поскольку эти приложения не отображают сигналы об ошибках для логических дефектов"
        },
        {
            "question": "Что такое генераторные функции?",
            "right_answer": "Введенные в версии ES6, генераторные функции являются особого класса функций."
        },
        {
            "question": "Какие различия между объявлением переменных с использованием var, let и const?",
            "right_answer": "До версии ES6 javascript использовалось только ключевое слово var для объявления переменных. С версией ES6 были введены ключевые слова let и const для объявления переменных."
        },
        {
            "question": "Что такое рекурсия в языке программирования?",
            "right_answer": "Рекурсия - это техника итерации операции путем повторного вызова функции самой себя до достижения результата."
        },
        {
            "question": "Каково различие в использовании Async/Await и Generators для достижения той же функциональности?",
            "right_answer": "Функции-генераторы выполняются пошагово, по одному выводу за раз, в то время как функции Async/await выполняются последовательно одна за другой. Async/await предоставляет определенный случай использования для более легкого выполнения генераторов. Результат вывода функции-генератора всегда имеет вид: значение X, выполнено: логическое значение, в то время как возвращаемое значение функции Async всегда является уверенностью или вызывает ошибку."
        },
        {
            "question": "Какой метод используется для извлечения символа из определенного индекса?",
            "right_answer": "Функция charAt() строки JavaScript находит элемент char по указанному индексу. Номер индекса начинается с 0 и продолжается до n-1, где n - длина строки. Значение индекса должно быть положительным, больше или равным длине строки."
        },
        {
            "question": "Какова роль отложенных скриптов в JavaScript?",
            "right_answer": "Обработка HTML-кода во время загрузки страницы отключается по умолчанию, пока скрипт не остановится. Ваша страница будет замедлена, если ваша сеть немного медленная или если скрипт очень громоздкий. Когда вы используете отложенный режим, скрипт ждет завершения разбора HTML перед его выполнением. Это сокращает время загрузки веб-страниц, позволяя им появляться быстрее."
        }
    ]
}