{
    "category_full_form": "Программист_Backend разработчик_Java + Spring",
    "category_human_form": "Backend разработчик_Java + Spring",
    "category_filename_form": "программист_backend-разработчик_java-spring",
    "questions": [
        {
            "question": "Может ли быть перегружен метод main?",
            "right_answer": "Да, метод main может быть перегружен столько раз, сколько мы захотим. Тем не менее, JVM предпочитает вызывать метод main с помощью своего предопределенного вызывающего метода."
        },
        {
            "question": "Может ли произойти превышение лимита памяти в программе, несмотря на наличие сборщика мусора?",
            "right_answer": "Да, даже при наличии сборщика мусора программа все равно может исчерпать память. Сборка мусора помогает идентифицировать и удалять объекты программы, которые больше не нужны, чтобы освободить используемые ими ресурсы. Когда объект в программе недостижим, выполняется сборка мусора относительно этого объекта. Если памяти недостаточно для создания новых объектов, сборщик мусора используется для освобождения памяти для удаленных из области объектов. Когда объем освобожденной памяти недостаточен для создания новых объектов, превышается лимит памяти программы."
        },
        {
            "question": "Как исключения влияют на программу, если их не обрабатывать?",
            "right_answer": "Если вы не обрабатываете исключение после его возникновения, программа завершится внезапно, и код после строки, где произошло исключение, не будет выполнен."
        },
        {
            "question": "Какие возможные способы сделать объекты доступными для сборки мусора (GC) в Java?",
            "right_answer": "Если переменная ссылки на объект удаляется из программы во время ее выполнения, объект может быть собран мусорщиком. Иногда их также называют недоступными объектами. Оператор new возвращает ссылку на объект после динамического выделения памяти для него."
        },
        {
            "question": "Могут ли статические методы быть переопределены?",
            "right_answer": "Нет, статические методы не могут быть переопределены в Java."
        },
        {
            "question": "Как достичь клонирования объектов в Java?",
            "right_answer": "Создание нового объекта с тем же состоянием, что и существующий объект, называется клонированием объектов в Java. Это можно достичь, реализуя интерфейс Cloneable и переопределяя метод clone() в классе."
        },
        {
            "question": "Что такое Композиция и Агрегация? Укажите разницу.",
            "right_answer": "Агрегация (HAS-A) и композиция - это две ее формы (Belongs-to). В отличие от композиции, которая имеет значительную корреляцию, агрегация имеет очень скромную связь. Агрегацию можно рассматривать как более ограниченную версию композиции. Поскольку все композиции являются агрегатами, но не все агрегаты являются композициями, агрегат можно рассматривать как надмножество композиции."
        },
        {
            "question": "Может ли в Java-программе существовать один блок try и несколько блоков catch? Объясните.",
            "right_answer": "Один или несколько блоков catch могут следовать за блоком try. Каждый блок catch должен иметь уникальный обработчик исключений. Поэтому, если вы хотите выполнить несколько задач в ответ на различные исключения, используйте мультиблок catch в Java."
        },
        {
            "question": "Различия между кучей и стековой памятью в Java",
            "right_answer": "Куча и стек - два типа памяти в Java, используемые для хранения данных. Куча используется для хранения объектов, в то время как стек используется для хранения локальных переменных и вызовов методов. Одним из основных различий между кучей и стековой памятью является их выделение и освобождение. Куча выделяется при создании объекта и освобождается, когда на этот объект больше нет ссылок. Стековая память, с другой стороны, выделяется при вызове метода и освобождается при возврате из метода. Еще одно различие между кучей и стековой памятью заключается в их размере. Куча больше стековой памяти, потому что используется для хранения объектов. Стековая память меньше, потому что используется только для хранения локальных переменных и вызовов методов."
        },
        {
            "question": "Что произойдет, если в одном классе в Java будет несколько методов main?",
            "right_answer": "Нет ограничения на количество основных методов, которые вы можете использовать. Перегрузка - это возможность иметь методы main с другими сигнатурами, чем main (String []), и JVM будет игнорировать эти методы main."
        },
        {
            "question": "Что такое синглтон класс в Java? И как реализовать синглтон класс?",
            "right_answer": "Класс, который может иметь только один объект в данный момент, называется синглтон классом. Чтобы реализовать синглтон класс, следует выполнить следующие шаги: Убедитесь, что в классе есть только один объект, Предоставьте глобальный доступ к этому объекту"
        },
        {
            "question": "Что вы понимаете под экземплярной переменной и локальной переменной?",
            "right_answer": "Обычно экземплярные переменные объявляются в классе, но вне методов, в то время как локальная переменная объявляется внутри блоков кода."
        },
        {
            "question": "Почему Java динамична?",
            "right_answer": "Java разработана для адаптации к изменяющейся среде. Программы на Java включают большое количество информации о времени выполнения, которая используется для разрешения доступа к объектам в реальном времени."
        },
        {
            "question": "Какое значение по умолчанию хранится в локальных переменных?",
            "right_answer": "Ни локальные переменные, ни примитивы и ссылки на объекты не имеют значения по умолчанию, хранящегося в них."
        },
        {
            "question": "Объясните итератор FailFast и итератор FailSafe вместе с примерами для каждого.",
            "right_answer": "Итераторы FailFast и FailSafe используются в коллекциях Java. Итераторы FailFast не позволяют вносить изменения или модификации в коллекции Java, что означает, что они завершаются, когда в коллекцию добавляется последний элемент или удаляется существующий элемент. Итераторы FailFast обычно завершаются и генерируют исключение под названием ConcurrentModificationException. Например: ArrayList, HashMap. С другой стороны, итераторы FailSafe позволяют вносить изменения или модификации в коллекции Java. Это возможно, поскольку итераторы FailSafe обычно работают с клонированной копией коллекции. Поэтому они не генерируют никакого конкретного исключения. Например: CopyOnWriteArrayList."
        }
    ]
}