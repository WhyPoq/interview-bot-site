{
    "category_full_form": "Программист_Frontend разработчик_Vue",
    "category_human_form": "Frontend разработчик_Vue",
    "category_filename_form": "программист_frontend-разработчик_vue",
    "questions": [
        {
            "question": "Нужно ли заменять весь локальный стейт на vuex?",
            "right_answer": "Нет, если часть стейта строго принадлежит одному компоненту, то вполне можно оставить его как локальный стейт. То есть, даже если vuex используется в приложении, это не означает, что нужно держать весь локальный стейт в хранилище vuex. Кроме того, код становится более громоздким и косвенным, хотя это делает мутации стейта более явными и отлаживаемыми."
        },
        {
            "question": "Что такое геттеры Vuex?",
            "right_answer": "Геттеры Vuex действуют как вычисляемые свойства для хранилищ, чтобы вычислять производное состояние на основе состояния хранилища. Подобно вычисляемым свойствам, результат геттера кэшируется на основе его зависимостей и будет переоцениваться только тогда, когда некоторые из его зависимостей изменились."
        },
        {
            "question": "Нужен ли мне Promise для vuex?",
            "right_answer": "Да, vuex требует Promise. Если ваши поддерживаемые браузеры не реализуют Promise (например, IE), вы можете использовать библиотеку полифиллов, такую как es6-promise, используя npm или yarn."
        },
        {
            "question": "Как создать поведение, похожее на плагины пользовательского интерфейса?",
            "right_answer": "Вы также можете добавить файлы, которые будут вести себя как плагины пользовательского интерфейса с помощью опции vuePlugins.ui\n{\n  \"vuePlugins\": {\n    \"ui\": [\"my-ui.js\"]\n  }\n}"
        },
        {
            "question": "Рекомендуется ли использовать async для вычисляемых свойств?",
            "right_answer": "Нет, это не рекомендуется. Вычисляемые свойства должны быть синхронными. Но если вы все равно используете асинхронные действия внутри них, они могут не работать ожидаемым образом и привести к непредвиденному поведению."
        },
        {
            "question": "Какова основная разница между методом и вычисляемым свойством?",
            "right_answer": "Основное различие между вычисляемым свойством и методом заключается в том, что вычисляемые свойства кэшируются и вызываются/изменяются только при изменении их зависимостей. В то время как метод будет вычисляться каждый раз, когда он вызывается."
        },
        {
            "question": "Какова цель опции комментариев?",
            "right_answer": "Когда опция комментариев включена, она сохраняет и отображает HTML-комментарии, найденные в шаблонах. По умолчанию ее значение равно false."
        },
        {
            "question": "Что такое пользовательские блоки?",
            "right_answer": "Вы можете определить пользовательские языковые блоки внутри файлов *.vue на основе атрибута lang блока, имени тега блока и правил в вашем конфигурационном файле webpack. Вы также можете использовать resourceQuery для сопоставления правила с пользовательским блоком без lang."
        },
        {
            "question": "Какова цель тега keep-alive?",
            "right_answer": "Тег keep-alive является абстрактным компонентом, используемым для сохранения состояния компонента или избегания повторного рендеринга. Когда вы оборачиваете тег вокруг динамического компонента, он кэширует неактивные экземпляры компонента, не уничтожая их."
        },
        {
            "question": "Как достичь условной группы элементов?",
            "right_answer": "Вы можете достичь условной группы элементов (переключение нескольких элементов одновременно), применив директиву v-if к элементу <template>, который работает как невидимая оболочка (без отображения) для группы элементов."
        },
        {
            "question": "Что такое фильтры?",
            "right_answer": "Фильтры могут использоваться для применения общего форматирования текста. Эти фильтры должны быть добавлены в конец выражения JavaScript, обозначенного символом «pipe». Вы можете использовать их в двух конкретных случаях: интерполяции мустаче и выражениях v-bind."
        },
        {
            "question": "Что такое доступ в стиле метода?",
            "right_answer": "Вы можете получить доступ к состоянию хранилища в стиле метода, передавая аргументы."
        },
        {
            "question": "Протекают ли стили родительского компонента в дочерние компоненты в области видимости CSS?",
            "right_answer": "Стили родительского компонента не протекут в дочерние компоненты. Однако корневой узел дочернего компонента будет затронут как стилями области видимости родительского компонента, так и стилями области видимости дочернего компонента. То есть, если у корневого элемента дочернего компонента есть класс, который также существует в родительском компоненте, стили родительского компонента протекут в дочерний. В любом случае, это сделано специально, чтобы родитель мог стилизовать корневой элемент дочернего компонента для целей макета."
        },
        {
            "question": "Что такое приоритет сопоставления маршрутов?",
            "right_answer": "Иногда URL может соответствовать нескольким маршрутам, и путаницу в том, какой маршрут нужно сопоставить, разрешает приоритет сопоставления маршрутов. Приоритет определяется порядком конфигурации маршрутов. То есть, маршрут, объявленный первым, имеет более высокий приоритет."
        },
        {
            "question": "Как использовать глубокие селекторы?",
            "right_answer": "В области видимости css, если вам нужно изменить стили дочернего компонента, используя глубокие селекторы (т. е. из родительского области видимости css), то вам нужно использовать комбинатор >>>."
        }
    ]
}