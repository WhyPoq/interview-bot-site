<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vue топ 12 вопросов для Frontend разработчик на собеседовании</title>
		<meta
			name="description"
			content="Часто задаваемые вопросы с правильными ответами на собеседовании на позицию Frontend разработчик по теме Vue"
		/>
		<meta
			name="keywords"
			content="Vue, Frontend разработчик, Программист, подготовка к собеседованию, вопросы для собеседования, вопросы на собеседование, собеседование, интервью, interview bot, интервью бот"
		/>

		<link rel="icon" type="image/x-icon" href="/Assets/favicon.ico?v=2" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		<link rel="stylesheet" href="/common.css" />
		<link rel="stylesheet" href="questions.css" />
	</head>
	<body>
		<header class="main-page-link">
			<a href="/" aria-label="Перейти на главную страницу">
				<div class="main-page-link-logo">
					<img src="/Assets/logo_small.webp" alt="Логотип interview bot" />
				</div>
			</a>
			<p>Interview bot</p>
		</header>
		<main>
			<h1>
				<div class="weak-h1">Вопросы для собеседования на тему</div>
				<div class="strong-h1">Frontend разработчик Vue</div>
			</h1>

			<ol>
				<li>
					<h2>Какой лучший способ повторного рендеринга компонента?</h2>
					<p>Лучший способ заставить Vue повторно отрисовать компонент - установить :key на компоненте. То есть, когда нужно повторно отрисовать компонент, просто измените значение ключа, и Vue повторно отрисует компонент.</p>
				</li>
				<li>
					<h2>Как вы работаете с препроцессорами, используя загрузчик vue?</h2>
					<p>Vue-loader автоматически определит правильные загрузчики для использования на основе атрибута lang блока языка и правил, определенных в конфигурации webpack. Вы можете использовать препроцессоры, такие как SASS, LESS, Stylus и PostCSS, используя загрузчик vuejs.</p>
				</li>
				<li>
					<h2>Как можно объединить локальные вычисляемые свойства с помощью вспомогательной функции mapState?</h2>
					<p>Вы можете использовать синтаксис оператора распространения объекта для объединения вспомогательной функции mapState (которая возвращает объект) с другими локальными вычисляемыми свойствами. Таким образом, упрощаются техники слияния с использованием утилит.</p>
				</li>
				<li>
					<h2>Какие существуют методы обнаружения массива, не изменяющие его?</h2>
					<p>Методы, которые не изменяют исходный массив, а всегда возвращают новый массив, называются методами без мутации. Ниже приведен список методов без мутации: filter(), concat(), slice().</p>
				</li>
				<li>
					<h2>Что такое плагин vuex?</h2>
					<p>Плагин vuex - это опция, которая предоставляет хуки для каждой мутации. Это обычная функция, которая принимает хранилище в качестве единственного аргумента. Вы можете создать свой собственный плагин или использовать встроенные плагины.</p>
				</li>
				<li>
					<h2>Что такое vuetify?</h2>
					<p>Vuetify - это семантический компонентный материальный фреймворк для Vue. Он стремится предоставить чистые, семантические и многократно используемые компоненты, которые облегчают создание приложений.</p>
				</li>
				<li>
					<h2>Что такое однофайловые компоненты?</h2>
					<p>Однофайловые компоненты - это простая концепция. Раньше вы могли слышать, что все три части (HTML, JavaScript и CSS) вашего приложения хранятся в разных компонентах. Но однофайловые компоненты объединяют структуру, стили и поведение в один файл. В начале может показаться странным иметь все три части в одном файле, но на самом деле это имеет гораздо больший смысл.</p>
				</li>
				<li>
					<h2>Как осуществляется изменение локали?</h2>
					<p>Все дочерние компоненты корневого экземпляра локализуются с использованием свойства locale класса VueI18n. Вы можете изменить значение свойства locale экземпляра VueI18n как показано ниже...</p>
				</li>
				<li>
					<h2>Какова цель строгого режима в vuex?</h2>
					<p>В строгом режиме, при каждом изменении состояния Vuex вне обработчиков мутаций будет сгенерирована ошибка. Это гарантирует, что все изменения состояния могут быть явно отслежены средствами отладки. Просто включите это, передав strict: true при создании хранилища vuex.</p>
				</li>
				<li>
					<h2>Что такое пользовательские блоки?</h2>
					<p>Вы можете определить пользовательские языковые блоки внутри файлов *.vue на основе атрибута lang блока, имени тега блока и правил в вашем конфигурационном файле webpack. Вы также можете использовать resourceQuery для сопоставления правила с пользовательским блоком без lang.</p>
				</li>
				<li>
					<h2>Что такое горячая перезагрузка в vue loader?</h2>
					<p>Горячая перезагрузка не заключается в перезагрузке страницы при редактировании любого файла .vue. Вместо этого, при редактировании файла *.vue все экземпляры этого компонента будут заменены без перезагрузки страницы. Это улучшает опыт разработки при настройке шаблонов или стилей ваших компонентов.</p>
				</li>
				<li>
					<h2>Что такое правила преобразования URL-адресов ресурсов?</h2>
					<p>Ниже приведен список правил преобразования URL-адресов ресурсов

Абсолютный путь: Если URL-адрес является абсолютным путем (например, /images/loader.png), то он будет сохранен как есть.
Относительный путь: Если URL-адрес начинается с . (например, ./images/loader.png), то он будет интерпретирован как относительный запрос модуля и разрешен на основе структуры папок на вашем файловой системе.
URL-адреса, начинающиеся с символа ~: Если URL-адрес начинается с символа ~ (например, ./some-node-package/loader.png), то он интерпретируется как запрос модуля. Таким образом, он может ссылаться на ресурсы внутри узловых модулей.
URL-адреса, начинающиеся с символа @: Если URL-адрес начинается с символа @, то он интерпретируется как запрос модуля. Это полезно, если ваша конфигурация webpack имеет псевдоним для @, который по умолчанию указывает на путь /src.</p>
				</li>
			</ol>
		</main>

		<footer>
			<p class="more-question">
				Больше вопросов у нашего
				<a class="telegram-bot-link" href="https://t.me/interview_training_bot"
					>телеграм бота</a
				>
			</p>
			<p>
				Там вы можете отвечать на вопросы голосовыми сообщениями и нейронная сеть проверит
				ваш ответ и даст фидбэк
			</p>
		</footer>
	</body>
</html>

