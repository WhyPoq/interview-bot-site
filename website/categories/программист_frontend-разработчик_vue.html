<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vue топ 15 вопросов для Frontend разработчик на собеседовании</title>
		<meta
			name="description"
			content="Часто задаваемые вопросы с правильными ответами на собеседовании на позицию Frontend разработчик по теме Vue"
		/>
		<meta
			name="keywords"
			content="Vue, Frontend разработчик, Программист, подготовка к собеседованию, вопросы для собеседования, вопросы на собеседование, собеседование, интервью, interview bot, интервью бот"
		/>

		<link rel="icon" type="image/x-icon" href="/Assets/favicon.ico" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		<link rel="stylesheet" href="/common.css" />
		<link rel="stylesheet" href="questions.css" />
	</head>
	<body>
		<header class="main-page-link">
			<a href="/" aria-label="Перейти на главную страницу">
				<div class="main-page-link-logo">
					<img src="/Assets/logo_small.webp" alt="Логотип interview bot" />
				</div>
			</a>
			<p>Interview bot</p>
		</header>
		<main>
			<h1>
				<div class="weak-h1">Вопросы для собеседования на тему</div>
				<div class="strong-h1">Frontend разработчик Vue</div>
			</h1>

			<ol>
				<li>
					<h2>Нужно ли заменять весь локальный стейт на vuex?</h2>
					<p>Нет, если часть стейта строго принадлежит одному компоненту, то вполне можно оставить его как локальный стейт. То есть, даже если vuex используется в приложении, это не означает, что нужно держать весь локальный стейт в хранилище vuex. Кроме того, код становится более громоздким и косвенным, хотя это делает мутации стейта более явными и отлаживаемыми.</p>
				</li>
				<li>
					<h2>Что такое геттеры Vuex?</h2>
					<p>Геттеры Vuex действуют как вычисляемые свойства для хранилищ, чтобы вычислять производное состояние на основе состояния хранилища. Подобно вычисляемым свойствам, результат геттера кэшируется на основе его зависимостей и будет переоцениваться только тогда, когда некоторые из его зависимостей изменились.</p>
				</li>
				<li>
					<h2>Нужен ли мне Promise для vuex?</h2>
					<p>Да, vuex требует Promise. Если ваши поддерживаемые браузеры не реализуют Promise (например, IE), вы можете использовать библиотеку полифиллов, такую как es6-promise, используя npm или yarn.</p>
				</li>
				<li>
					<h2>Как создать поведение, похожее на плагины пользовательского интерфейса?</h2>
					<p>Вы также можете добавить файлы, которые будут вести себя как плагины пользовательского интерфейса с помощью опции vuePlugins.ui
{
  &quot;vuePlugins&quot;: {
    &quot;ui&quot;: [&quot;my-ui.js&quot;]
  }
}</p>
				</li>
				<li>
					<h2>Рекомендуется ли использовать async для вычисляемых свойств?</h2>
					<p>Нет, это не рекомендуется. Вычисляемые свойства должны быть синхронными. Но если вы все равно используете асинхронные действия внутри них, они могут не работать ожидаемым образом и привести к непредвиденному поведению.</p>
				</li>
				<li>
					<h2>Какова основная разница между методом и вычисляемым свойством?</h2>
					<p>Основное различие между вычисляемым свойством и методом заключается в том, что вычисляемые свойства кэшируются и вызываются/изменяются только при изменении их зависимостей. В то время как метод будет вычисляться каждый раз, когда он вызывается.</p>
				</li>
				<li>
					<h2>Какова цель опции комментариев?</h2>
					<p>Когда опция комментариев включена, она сохраняет и отображает HTML-комментарии, найденные в шаблонах. По умолчанию ее значение равно false.</p>
				</li>
				<li>
					<h2>Что такое пользовательские блоки?</h2>
					<p>Вы можете определить пользовательские языковые блоки внутри файлов *.vue на основе атрибута lang блока, имени тега блока и правил в вашем конфигурационном файле webpack. Вы также можете использовать resourceQuery для сопоставления правила с пользовательским блоком без lang.</p>
				</li>
				<li>
					<h2>Какова цель тега keep-alive?</h2>
					<p>Тег keep-alive является абстрактным компонентом, используемым для сохранения состояния компонента или избегания повторного рендеринга. Когда вы оборачиваете тег вокруг динамического компонента, он кэширует неактивные экземпляры компонента, не уничтожая их.</p>
				</li>
				<li>
					<h2>Как достичь условной группы элементов?</h2>
					<p>Вы можете достичь условной группы элементов (переключение нескольких элементов одновременно), применив директиву v-if к элементу &lt;template&gt;, который работает как невидимая оболочка (без отображения) для группы элементов.</p>
				</li>
				<li>
					<h2>Что такое фильтры?</h2>
					<p>Фильтры могут использоваться для применения общего форматирования текста. Эти фильтры должны быть добавлены в конец выражения JavaScript, обозначенного символом «pipe». Вы можете использовать их в двух конкретных случаях: интерполяции мустаче и выражениях v-bind.</p>
				</li>
				<li>
					<h2>Что такое доступ в стиле метода?</h2>
					<p>Вы можете получить доступ к состоянию хранилища в стиле метода, передавая аргументы.</p>
				</li>
				<li>
					<h2>Протекают ли стили родительского компонента в дочерние компоненты в области видимости CSS?</h2>
					<p>Стили родительского компонента не протекут в дочерние компоненты. Однако корневой узел дочернего компонента будет затронут как стилями области видимости родительского компонента, так и стилями области видимости дочернего компонента. То есть, если у корневого элемента дочернего компонента есть класс, который также существует в родительском компоненте, стили родительского компонента протекут в дочерний. В любом случае, это сделано специально, чтобы родитель мог стилизовать корневой элемент дочернего компонента для целей макета.</p>
				</li>
				<li>
					<h2>Что такое приоритет сопоставления маршрутов?</h2>
					<p>Иногда URL может соответствовать нескольким маршрутам, и путаницу в том, какой маршрут нужно сопоставить, разрешает приоритет сопоставления маршрутов. Приоритет определяется порядком конфигурации маршрутов. То есть, маршрут, объявленный первым, имеет более высокий приоритет.</p>
				</li>
				<li>
					<h2>Как использовать глубокие селекторы?</h2>
					<p>В области видимости css, если вам нужно изменить стили дочернего компонента, используя глубокие селекторы (т. е. из родительского области видимости css), то вам нужно использовать комбинатор &gt;&gt;&gt;.</p>
				</li>
			</ol>
		</main>

		<footer>
			<p class="more-question">
				Больше вопросов у нашего
				<a class="telegram-bot-link" href="https://t.me/interview_training_bot"
					>телеграм бота</a
				>
			</p>
			<p>
				Там вы можете отвечать на вопросы голосовыми сообщениями и нейронная сеть проверит
				ваш ответ и даст фидбэк
			</p>
		</footer>
	</body>
</html>

