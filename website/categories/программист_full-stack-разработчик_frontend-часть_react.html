<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>React топ 15 вопросов для Full Stack разработчик на собеседовании</title>
		<meta
			name="description"
			content="Часто задаваемые вопросы с правильными ответами на собеседовании на позицию Full Stack разработчик по теме React"
		/>
		<meta
			name="keywords"
			content="React, Frontend часть, Full Stack разработчик, Программист, подготовка к собеседованию, вопросы для собеседования, вопросы на собеседование, собеседование, интервью, interview bot, интервью бот"
		/>

		<link rel="icon" type="image/x-icon" href="/Assets/favicon.ico" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		<link rel="stylesheet" href="/common.css" />
		<link rel="stylesheet" href="questions.css" />
	</head>
	<body>
		<header class="main-page-link">
			<a href="/" aria-label="Перейти на главную страницу">
				<div class="main-page-link-logo">
					<img src="/Assets/logo_small.webp" alt="Логотип interview bot" />
				</div>
			</a>
			<p>Interview bot</p>
		</header>
		<main>
			<h1>
				<div class="weak-h1">Вопросы для собеседования на тему</div>
				<div class="strong-h1">Full Stack разработчик React</div>
			</h1>

			<ol>
				<li>
					<h2>Как обрабатывать асинхронные действия в Redux Thunk?</h2>
					<p>Чтобы использовать Redux Thunk, вам нужно импортировать его как промежуточное ПО. Создатели действий должны возвращать не только объект, но и функцию, которая принимает диспетчер в качестве параметра.</p>
				</li>
				<li>
					<h2>Что такое React Context?</h2>
					<p>React Context - это функция, которая предоставляет способ передачи данных через дерево компонентов без ручной передачи props на каждом уровне. Она позволяет создать глобальное состояние, к которому можно обратиться из любого компонента в дереве, независимо от его положения. Context полезен, когда вам нужно обмениваться данными между несколькими компонентами, которые не прямо связаны через props.</p>
				</li>
				<li>
					<h2>Что такое менеджер состояния и с какими из них вы работали или знаете?</h2>
					<p>Менеджер состояния - это инструмент или библиотека, которая помогает управлять состоянием приложения. Он предоставляет централизованное хранилище или контейнер для хранения и управления данными, к которым могут обращаться и обновлять их различные компоненты в приложении. Менеджер состояния решает несколько проблем. Во-первых, это хорошая практика разделять данные и связанную с ними логику от компонентов. Во-вторых, при использовании локального состояния и передаче его между компонентами код может стать запутанным из-за потенциальной глубокой вложенности компонентов. Имея глобальное хранилище, мы можем получать доступ и изменять данные из любого компонента. Вместе с React Context, Redux или MobX часто используются в качестве библиотек управления состоянием.</p>
				</li>
				<li>
					<h2>Каковы правила создания пользовательского хука?</h2>
					<p>Начинайте название хука с &#x27;use&#x27;. Используйте существующие хуки при необходимости. Не вызывайте хуки условно. Извлекайте повторяющуюся логику в пользовательский хук. Пользовательские хуки должны быть чистыми функциями. Пользовательские хуки могут возвращать значения или другие хуки. Называйте пользовательский хук описательно.</p>
				</li>
				<li>
					<h2>В чем разница между useMemo и useCallback?</h2>
					<p>useMemo используется для кэширования результата вычисления, в то время как useCallback используется для кэширования самой функции. useMemo кэширует вычисленное значение и возвращает его на последующих рендерах, если зависимости не изменились. useCallback кэширует саму функцию и возвращает тот же экземпляр, пока зависимости не изменились.</p>
				</li>
				<li>
					<h2>Как получить доступ к элементу DOM?</h2>
					<p>Ссылки создаются с помощью React.createRef() или хука useRef() и присоединяются к элементам React через атрибут ref. Обращаясь к созданной ссылке, мы можем получить доступ к элементу DOM, используя ref.current.</p>
				</li>
				<li>
					<h2>Что такое SSR (Server-Side Rendering)?</h2>
					<p>Серверный рендеринг (SSR) - это техника, используемая для отрисовки страниц на сервере и отправки полностью отрисованной страницы клиенту для отображения. Она позволяет серверу генерировать полный HTML-код веб-страницы, включая ее динамическое содержимое, и отправлять его клиенту в качестве ответа на запрос.</p>
				</li>
				<li>
					<h2>Какие архитектурные решения для React вы знаете?</h2>
					<p>Существует несколько архитектурных решений и шаблонов для создания проектов на React. Некоторые популярные включают: MVC, Flux, Atomic Design, Container and Component Pattern и Feature-Sliced Design.</p>
				</li>
				<li>
					<h2>Какие React хуки вы знаете?</h2>
					<p>useState: Используется для управления состоянием в функциональных компонентах. useEffect: Используется для выполнения побочных эффектов в функциональных компонентах, таких как получение данных или подписка на события. useContext: Используется для доступа к значению контекста React внутри функционального компонента. useRef: Используется для создания изменяемых ссылок на элементы или значения, которые сохраняются между рендерами. useCallback: Используется для мемоизации функций, чтобы предотвратить ненужные повторные рендеры. useMemo: Используется для мемоизации значений для улучшения производительности путем кэширования дорогостоящих вычислений. useReducer: Используется для управления состоянием с помощью функции редуктора, аналогично тому, как работает Redux. useLayoutEffect: Похож на useEffect, но эффект выполняется синхронно после всех мутаций DOM. Эти хуки предоставляют мощные инструменты для управления состоянием, обработки побочных эффектов и повторного использования логики в функциональных компонентах React.</p>
				</li>
				<li>
					<h2>Что такое линтеры?</h2>
					<p>Линтеры - это инструменты, используемые для проверки исходного кода на потенциальные ошибки, баги, стилистические несоответствия и проблемы поддерживаемости. Они помогают соблюдать стандарты кодирования и обеспечивают качество и последовательность кода в рамках кодовой базы.</p>
				</li>
				<li>
					<h2>Для чего используется useCallback и как она работает?</h2>
					<p>Хук useCallback вернет мемоизированную версию обратного вызова, которая изменится только в случае изменения значений одной из зависимостей. Это полезно при передаче обратных вызовов в оптимизированные дочерние компоненты, которые полагаются на равенство ссылок для предотвращения ненужных перерисовок. const callbackValue = useCallback(() =&gt; computeFunc(paramA, paramB), [paramA, paramB]);</p>
				</li>
				<li>
					<h2>Какие особенности использования useState?</h2>
					<p>useState возвращает значение состояния и функцию для его обновления. Во время первоначального рендеринга возвращенное состояние соответствует значению, переданному в качестве первого аргумента. Функция setState используется для обновления состояния. Она принимает новое значение состояния в качестве параметра и добавляет перерисовку компонента в очередь. Функция setState также может принимать функцию обратного вызова в качестве параметра, которая принимает предыдущее значение состояния в качестве параметра.</p>
				</li>
				<li>
					<h2>Какой паттерн реализует Mobx?</h2>
					<p>Mobx реализует паттерн Observer, также известный как Publish-Subscribe паттерн.</p>
				</li>
				<li>
					<h2>Какой паттерн реализует Redux?</h2>
					<p>Redux реализует паттерн Flux, который является предсказуемым паттерном управления состоянием для приложений. Он помогает управлять состоянием приложения, вводя однонаправленный поток данных и централизованное хранилище для состояния приложения.</p>
				</li>
				<li>
					<h2>Что такое props drilling?</h2>
					<p>Props drilling относится к процессу передачи пропсов через несколько уровней вложенных компонентов, даже если некоторые промежуточные компоненты не используют эти пропсы напрямую. Это может привести к сложной и громоздкой структуре кода.</p>
				</li>
			</ol>
		</main>

		<footer>
			<p class="more-question">
				Больше вопросов у нашего
				<a class="telegram-bot-link" href="https://t.me/interview_training_bot"
					>телеграм бота</a
				>
			</p>
			<p>
				Там вы можете отвечать на вопросы голосовыми сообщениями и нейронная сеть проверит
				ваш ответ и даст фидбэк
			</p>
		</footer>
	</body>
</html>

