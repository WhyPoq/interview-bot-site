<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Javascript топ 15 вопросов для Frontend разработчик на собеседовании</title>
		<meta
			name="description"
			content="Часто задаваемые вопросы с правильными ответами на собеседовании на позицию Frontend разработчик по теме Javascript"
		/>
		<meta
			name="keywords"
			content="Javascript, Frontend разработчик, Программист, подготовка к собеседованию, вопросы для собеседования, вопросы на собеседование, собеседование, интервью, interview bot, интервью бот"
		/>

		<link rel="icon" type="image/x-icon" href="/Assets/favicon.ico" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		<link rel="stylesheet" href="/common.css" />
		<link rel="stylesheet" href="questions.css" />
	</head>
	<body>
		<header class="main-page-link">
			<a href="/" aria-label="Перейти на главную страницу">
				<div class="main-page-link-logo">
					<img src="/Assets/logo_small.webp" alt="Логотип interview bot" />
				</div>
			</a>
			<p>Interview bot</p>
		</header>
		<main>
			<h1>
				<div class="weak-h1">Вопросы для собеседования на тему</div>
				<div class="strong-h1">Frontend разработчик Javascript</div>
			</h1>

			<ol>
				<li>
					<h2>Что такое генераторные функции?</h2>
					<p>Введенные в версии ES6, генераторные функции являются особого класса функций.</p>
				</li>
				<li>
					<h2>Объясните ключевое слово «this».</h2>
					<p>Ключевое слово «this» относится к объекту, свойством которого является функция.</p>
				</li>
				<li>
					<h2>Что такое Immediately Invoked Function в JavaScript?</h2>
					<p>Immediately Invoked Function (IIFE) - это функция, которая запускается сразу после определения.</p>
				</li>
				<li>
					<h2>Что нужно сделать, чтобы внедрить Лексическую область видимости на практике?</h2>
					<p>Для поддержки лексической области видимости внутреннее состояние объекта функции JavaScript должно включать не только код функции, но и ссылку на текущую цепочку области видимости.</p>
				</li>
				<li>
					<h2>Объясните Scope и Scope Chain в javascript.</h2>
					<p>Scope в JS определяет доступность переменных и функций в различных частях кода.</p>
				</li>
				<li>
					<h2>Что вы понимаете под шаблонами проектирования JavaScript?</h2>
					<p>Шаблоны проектирования JavaScript - это повторяемые подходы к ошибкам, которые иногда возникают при создании браузерных приложений на JavaScript. Они действительно помогают нам сделать наш код более стабильным. Они в основном делятся на 3 категории: Шаблон создания объектов, Структурный шаблон проектирования, Поведенческий шаблон проектирования.</p>
				</li>
				<li>
					<h2>Какие примитивные типы данных существуют в JavaScript?</h2>
					<p>Примитив - это тип данных, который не состоит из других типов данных. Он способен отображать только одно значение за раз. По определению, каждый примитив является встроенным типом данных (компилятор должен знать о них), однако не все встроенные наборы данных являются примитивами. В JavaScript существует 5 различных форм базовых данных. Доступны следующие значения: Boolean, Undefined, Null, Number, String</p>
				</li>
				<li>
					<h2>Почему мы используем слово «отладчик» в javascript?</h2>
					<p>Отладчик для браузера должен быть активирован для отладки кода. Встроенные отладчики могут быть включены и выключены, требуя от пользователя сообщения о неисправностях. Оставшаяся часть кода должна остановить выполнение перед переходом к следующей строке во время отладки.</p>
				</li>
				<li>
					<h2>Какой метод используется для извлечения символа из определенного индекса?</h2>
					<p>Функция charAt() строки JavaScript находит элемент char по указанному индексу. Номер индекса начинается с 0 и продолжается до n-1, где n - длина строки. Значение индекса должно быть положительным, больше или равным длине строки.</p>
				</li>
				<li>
					<h2>Объясните передачу по значению и передачу по ссылке.</h2>
					<p>В JavaScript примитивные типы данных передаются по значению, а не примитивные типы данных передаются по ссылке.</p>
				</li>
				<li>
					<h2>Для чего используется конструкторная функция в javascript?</h2>
					<p>Конструкторные функции используются для создания объектов в javascript.</p>
				</li>
				<li>
					<h2>Объясните методы call(), apply() и bind().</h2>
					<p>1. call():

Это предопределенный метод в javascript.
Этот метод вызывает метод (функцию), указывая объект-владельца.
Пример 1:
function sayHello(){
  return &quot;Hello &quot; + this.name;
}

var obj = {name: &quot;Sandy&quot;};

sayHello.call(obj);

// Возвращает &quot;Hello Sandy&quot;
Метод call() позволяет объекту использовать метод (функцию) другого объекта.
Пример 2:
var person = {
  age: 23,
  getAge: function(){
    return this.age;
  }
}
var person2 = {age:  54};
person.getAge.call(person2);
// Возвращает 54
Метод call() принимает аргументы:
function saySomething(message){
  return this.name + &quot; is &quot; + message;
}
var person4 = {name:  &quot;John&quot;};
saySomething.call(person4, &quot;awesome&quot;);
// Возвращает &quot;John is awesome&quot;

apply()

Метод apply аналогичен методу call(). Единственное отличие в том, что,

метод call() принимает аргументы отдельно, в то время как метод apply() принимает аргументы в виде массива.

function saySomething(message){
  return this.name + &quot; is &quot; + message;
}
var person4 = {name:  &quot;John&quot;};
saySomething.apply(person4, [&quot;awesome&quot;]);

2. bind():

Этот метод возвращает новую функцию, где значение ключевого слова “this” будет привязано к объекту-владельцу, который предоставляется в качестве параметра.
Пример с аргументами:
var bikeDetails = {
    displayDetails: function(registrationNumber,brandName){
    return this.name+ &quot; , &quot;+ &quot;bike details: &quot;+ registrationNumber + &quot; , &quot; + brandName;
  }
}

var person1 = {name:  &quot;Vivek&quot;};

var detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, &quot;TS0122&quot;, &quot;Bullet&quot;);

// Привязывает функцию displayDetails к объекту person1


detailsOfPerson1();
// Возвращает Vivek, bike details: TS0122, Bullet</p>
				</li>
				<li>
					<h2>Укажите некоторые преимущества JavaScript.</h2>
					<p>У JavaScript есть много преимуществ. Некоторые из них: JavaScript выполняется как на стороне клиента, так и на стороне сервера. Существует множество фронтенд-фреймворков, которые вы можете изучить и использовать. Однако, если вы хотите использовать JavaScript на бэкенде, вам нужно будет изучить NodeJS. В настоящее время это единственный фреймворк JavaScript, который можно использовать на бэкенде. JavaScript - простой язык для изучения. Веб-страницы теперь имеют больше функциональности благодаря JavaScript. Для конечного пользователя JavaScript работает довольно быстро.</p>
				</li>
				<li>
					<h2>В чем разница между прототипным и классическим наследованием?</h2>
					<p>Программисты создают объекты, которые являются представлениями сущностей реального времени, в традиционном ОО программировании. Классы и объекты - два вида абстракций. Класс является обобщением объекта, в то время как объект является абстракцией реального объекта. Например, Транспортное средство - это специализация Автомобиля. В результате, автомобили (класс) происходят от транспортных средств (объект).

Классическое наследование отличается от прототипного наследования тем, что классическое наследование ограничено классами, которые наследуются от оставшихся классов, в то время как прототипное наследование позволяет любому объекту быть клонированным с помощью метода связывания объектов. Несмотря на слишком многочисленные детали, прототип в основном служит шаблоном для других объектов, независимо от того, расширяют ли они родительский объект или нет.</p>
				</li>
				<li>
					<h2>Каково различие между ключевыми словами var и let в JavaScript?</h2>
					<p>Некоторые различия: С самого начала ключевое слово &#x27;var&#x27; использовалось в программировании на JavaScript, в то время как ключевое слово &#x27;let&#x27; было добавлено только в 2015 году. Ключевое слово &#x27;var&#x27; имеет область видимости функции. В любом месте функции переменная, указанная с помощью var, доступна, но в случае с &#x27;let&#x27; область видимости переменной, объявленной с ключевым словом &#x27;let&#x27;, ограничена блоком, в котором она объявлена. Давайте начнем с области видимости блока. В ECMAScript 2015 let и const поднимаются, но не инициализируются. Ссылка на переменную в блоке до объявления переменной приводит к ошибке ReferenceError, потому что переменная находится в &#x27;временной зоне мертвых&#x27; с начала блока до обработки объявления.</p>
				</li>
			</ol>
		</main>

		<footer>
			<p class="more-question">
				Больше вопросов у нашего
				<a class="telegram-bot-link" href="https://t.me/interview_training_bot"
					>телеграм бота</a
				>
			</p>
			<p>
				Там вы можете отвечать на вопросы голосовыми сообщениями и нейронная сеть проверит
				ваш ответ и даст фидбэк
			</p>
		</footer>
	</body>
</html>

