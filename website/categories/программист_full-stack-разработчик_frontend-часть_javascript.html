<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>JavaScript топ 15 вопросов для Full Stack разработчик на собеседовании</title>
		<meta
			name="description"
			content="Часто задаваемые вопросы с правильными ответами на собеседовании на позицию Full Stack разработчик по теме JavaScript"
		/>
		<meta
			name="keywords"
			content="JavaScript, Frontend часть, Full Stack разработчик, Программист, подготовка к собеседованию, вопросы для собеседования, вопросы на собеседование, собеседование, интервью, interview bot, интервью бот"
		/>

		<link rel="icon" type="image/x-icon" href="/Assets/favicon.ico?v=2" />

		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		<link rel="stylesheet" href="/common.css" />
		<link rel="stylesheet" href="questions.css" />
	</head>
	<body>
		<header class="main-page-link">
			<a href="/" aria-label="Перейти на главную страницу">
				<div class="main-page-link-logo">
					<img src="/Assets/logo_small.webp" alt="Логотип interview bot" />
				</div>
			</a>
			<p>Interview bot</p>
		</header>
		<main>
			<h1>
				<div class="weak-h1">Вопросы для собеседования на тему</div>
				<div class="strong-h1">Full Stack разработчик JavaScript</div>
			</h1>

			<ol>
				<li>
					<h2>Объясните WeakMap в javascript.</h2>
					<p>В javascript Map используется для хранения пар ключ-значение. Пары ключ-значение могут быть как примитивных, так и не примитивных типов. WeakMap похож на Map с ключевыми различиями: ключи и значения в WeakMap должны всегда быть объектом. Если нет ссылок на объект, то объект будет собран сборщиком мусора.</p>
				</li>
				<li>
					<h2>Объясните Scope и Scope Chain в javascript.</h2>
					<p>Scope в JS определяет доступность переменных и функций в различных частях кода.</p>
				</li>
				<li>
					<h2>Объясните Замыкания в JavaScript.</h2>
					<p>Замыкания - это способность функции запоминать переменные и функции, объявленные в её внешней области видимости.</p>
				</li>
				<li>
					<h2>Что вы подразумеваете под шаблонами проектирования JavaScript?</h2>
					<p>Шаблоны проектирования JavaScript - это повторяемые подходы к ошибкам, которые иногда возникают при создании браузерных приложений на JavaScript. Они действительно помогают нам сделать наш код более стабильным. Они в основном делятся на 3 категории: Шаблон создания объектов, Структурный шаблон проектирования, Поведенческий шаблон проектирования.</p>
				</li>
				<li>
					<h2>Объясните методы call(), apply() и bind().</h2>
					<p>1. call():

Это предопределенный метод в javascript.
Этот метод вызывает метод (функцию), указывая объект-владельца.
Пример 1:
function sayHello(){
  return &quot;Hello &quot; + this.name;
}

var obj = {name: &quot;Sandy&quot;};

sayHello.call(obj);

// Возвращает &quot;Hello Sandy&quot;
Метод call() позволяет объекту использовать метод (функцию) другого объекта.
Пример 2:
var person = {
  age: 23,
  getAge: function(){
    return this.age;
  }
}
var person2 = {age:  54};
person.getAge.call(person2);
// Возвращает 54
Метод call() принимает аргументы отдельно:
function saySomething(message){
  return this.name + &quot; is &quot; + message;
}
var person4 = {name:  &quot;John&quot;};
saySomething.call(person4, &quot;awesome&quot;);
// Возвращает &quot;John is awesome&quot;

apply()

Метод apply аналогичен методу call(). Единственное отличие в том, что,

метод call() принимает аргументы отдельно, в то время как метод apply() принимает аргументы в виде массива.

function saySomething(message){
  return this.name + &quot; is &quot; + message;
}
var person4 = {name:  &quot;John&quot;};
saySomething.apply(person4, [&quot;awesome&quot;]);

2. bind():

Этот метод возвращает новую функцию, где значение ключевого слова “this” будет привязано к объекту-владельцу, который предоставляется в качестве параметра.
Пример с аргументами:
var bikeDetails = {
    displayDetails: function(registrationNumber,brandName){
    return this.name+ &quot; , &quot;+ &quot;детали велосипеда: &quot;+ registrationNumber + &quot; , &quot; + brandName;
  }
}

var person1 = {name:  &quot;Vivek&quot;};

var detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, &quot;TS0122&quot;, &quot;Bullet&quot;);

// Привязывает функцию displayDetails к объекту person1


detailsOfPerson1();
// Возвращает Vivek, детали велосипеда: TS0122, Bullet</p>
				</li>
				<li>
					<h2>Что такое прототипы объектов?</h2>
					<p>Все объекты JavaScript наследуют свойства от прототипа. Прототип - это чертеж объекта, который позволяет нам использовать свойства и методы объекта, даже если они не существуют в текущем объекте.</p>
				</li>
				<li>
					<h2>Что такое Temporal Dead Zone?</h2>
					<p>Temporal Dead Zone - это поведение, которое происходит с переменными, объявленными с использованием ключевых слов let и const. Это поведение, когда мы пытаемся получить доступ к переменной до ее инициализации.</p>
				</li>
				<li>
					<h2>Является ли JavaScript статически типизированным или динамически типизированным языком?</h2>
					<p>JavaScript является динамически типизированным языком. В динамически типизированном языке тип переменной проверяется во время выполнения, в отличие от статически типизированного языка, где тип переменной проверяется во время компиляции. Поскольку JavaScript является слабо (динамически) типизированным языком, переменные в JS не связаны с каким-либо типом. Переменная может содержать значение любого типа данных.</p>
				</li>
				<li>
					<h2>Какие типы ошибок существуют в JavaScript?</h2>
					<p>Существует два типа ошибок в JavaScript.
Синтаксическая ошибка: Синтаксические ошибки - это ошибки или проблемы с орфографией в коде, которые приводят к тому, что программа не выполняется вообще или останавливается на полпути. Обычно также предоставляются сообщения об ошибках.
Логическая ошибка: Ошибки рассуждения возникают, когда синтаксис правильный, но логика или программа неверны. В этом случае приложение выполняется без проблем. Однако результаты вывода недостоверны. Иногда их сложнее исправить, чем синтаксические проблемы, поскольку эти приложения не отображают сигналы об ошибках для логических дефектов</p>
				</li>
				<li>
					<h2>Что такое генераторные функции?</h2>
					<p>Введенные в версии ES6, генераторные функции являются особого класса функций.</p>
				</li>
				<li>
					<h2>Какие различия между объявлением переменных с использованием var, let и const?</h2>
					<p>До версии ES6 javascript использовалось только ключевое слово var для объявления переменных. С версией ES6 были введены ключевые слова let и const для объявления переменных.</p>
				</li>
				<li>
					<h2>Что такое рекурсия в языке программирования?</h2>
					<p>Рекурсия - это техника итерации операции путем повторного вызова функции самой себя до достижения результата.</p>
				</li>
				<li>
					<h2>Каково различие в использовании Async/Await и Generators для достижения той же функциональности?</h2>
					<p>Функции-генераторы выполняются пошагово, по одному выводу за раз, в то время как функции Async/await выполняются последовательно одна за другой. Async/await предоставляет определенный случай использования для более легкого выполнения генераторов. Результат вывода функции-генератора всегда имеет вид: значение X, выполнено: логическое значение, в то время как возвращаемое значение функции Async всегда является уверенностью или вызывает ошибку.</p>
				</li>
				<li>
					<h2>Какой метод используется для извлечения символа из определенного индекса?</h2>
					<p>Функция charAt() строки JavaScript находит элемент char по указанному индексу. Номер индекса начинается с 0 и продолжается до n-1, где n - длина строки. Значение индекса должно быть положительным, больше или равным длине строки.</p>
				</li>
				<li>
					<h2>Какова роль отложенных скриптов в JavaScript?</h2>
					<p>Обработка HTML-кода во время загрузки страницы отключается по умолчанию, пока скрипт не остановится. Ваша страница будет замедлена, если ваша сеть немного медленная или если скрипт очень громоздкий. Когда вы используете отложенный режим, скрипт ждет завершения разбора HTML перед его выполнением. Это сокращает время загрузки веб-страниц, позволяя им появляться быстрее.</p>
				</li>
			</ol>
		</main>

		<footer>
			<p class="more-question">
				Больше вопросов у нашего
				<a class="telegram-bot-link" href="https://t.me/interview_training_bot"
					>телеграм бота</a
				>
			</p>
			<p>
				Там вы можете отвечать на вопросы голосовыми сообщениями и нейронная сеть проверит
				ваш ответ и даст фидбэк
			</p>
		</footer>
	</body>
</html>

